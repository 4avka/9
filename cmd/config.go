package cmd

import (
	"time"

	"git.parallelcoin.io/dev/9/cmd/nine"
)

var config = MakeConfig(&Config)

func MakeConfig(c *Lines) (out *nine.Config) {
	var tn, sn, rn = new(bool), new(bool), new(bool)
	cfg := *c
	out = &nine.Config{
		ConfigFile:               nil,
		DataDir:                  cfg["app.datadir"].Value.(*string),
		LogDir:                   cfg["app.datadir"].Value.(*string),
		LogLevel:                 cfg["log.level"].Value.(*string),
		Subsystems:               cfg["log.subsystem"].Value.(*nine.Mapstringstring),
		Network:                  cfg["p2p.network"].Value.(*string),
		AddPeers:                 cfg["p2p.addpeer"].Value.(*[]string),
		ConnectPeers:             cfg["p2p.connect"].Value.(*[]string),
		MaxPeers:                 cfg["p2p.maxpeers"].Value.(*int),
		Listeners:                cfg["p2p.listen"].Value.(*[]string),
		DisableListen:            cfg["p2p.nolisten"].Value.(*bool),
		DisableBanning:           cfg["p2p.nobanning"].Value.(*bool),
		BanDuration:              cfg["p2p.banduration"].Value.(*time.Duration),
		BanThreshold:             cfg["p2p.banthreshold"].Value.(*int),
		Whitelists:               cfg["p2p.whitelist"].Value.(*[]string),
		Username:                 cfg["rpc.user"].Value.(*string),
		Password:                 cfg["rpc.pass"].Value.(*string),
		ServerUser:               cfg["rpc.user"].Value.(*string),
		ServerPass:               cfg["rpc.pass"].Value.(*string),
		LimitUser:                cfg["limit.user"].Value.(*string),
		LimitPass:                cfg["limit.pass"].Value.(*string),
		RPCConnect:               cfg["rpc.connect"].Value.(*string),
		RPCListeners:             cfg["rpc.listen"].Value.(*[]string),
		RPCCert:                  cfg["tls.cert"].Value.(*string),
		RPCKey:                   cfg["tls.key"].Value.(*string),
		RPCMaxClients:            cfg["rpc.maxclients"].Value.(*int),
		RPCMaxWebsockets:         cfg["rpc.maxwebsockets"].Value.(*int),
		RPCMaxConcurrentReqs:     cfg["rpc.maxconcurrentreqs"].Value.(*int),
		RPCQuirks:                cfg["rpc.quirks"].Value.(*bool),
		DisableRPC:               cfg["rpc.disable"].Value.(*bool),
		NoTLS:                    cfg["tls.disable"].Value.(*bool),
		DisableDNSSeed:           cfg["p2p.nodns"].Value.(*bool),
		ExternalIPs:              cfg["p2p.externalips"].Value.(*[]string),
		Proxy:                    cfg["proxy.address"].Value.(*string),
		ProxyUser:                cfg["proxy.user"].Value.(*string),
		ProxyPass:                cfg["proxy.pass"].Value.(*string),
		OnionProxy:               cfg["proxy.address"].Value.(*string),
		OnionProxyUser:           cfg["proxy.user"].Value.(*string),
		OnionProxyPass:           cfg["proxy.pass"].Value.(*string),
		Onion:                    cfg["proxy.tor"].Value.(*bool),
		TorIsolation:             cfg["proxy.isolation"].Value.(*bool),
		TestNet3:                 tn,
		RegressionTest:           rn,
		SimNet:                   sn,
		AddCheckpoints:           cfg["chain.addcheckpoints"].Value.(*[]string),
		DisableCheckpoints:       cfg["chain.disablecheckpoints"].Value.(*bool),
		DbType:                   cfg["chain.dbtype"].Value.(*string),
		Profile:                  cfg["app.profile"].Value.(*int),
		CPUProfile:               cfg["app.cpuprofile"].Value.(*string),
		Upnp:                     cfg["app.upnp"].Value.(*bool),
		MinRelayTxFee:            cfg["p2p.minrelaytxfee"].Value.(*float64),
		FreeTxRelayLimit:         cfg["p2p.freetxrelaylimit"].Value.(*float64),
		NoRelayPriority:          cfg["p2p.norelaypriority"].Value.(*bool),
		TrickleInterval:          cfg["p2p.trickleinterval"].Value.(*time.Duration),
		MaxOrphanTxs:             cfg["p2p.maxorphantxs"].Value.(*int),
		Algo:                     cfg["mining.algo"].Value.(*string),
		Generate:                 cfg["mining.generate"].Value.(*bool),
		GenThreads:               cfg["mining.genthreads"].Value.(*int),
		MiningAddrs:              cfg["mining.addresses"].Value.(*[]string),
		MinerListener:            cfg["mining.listener"].Value.(*string),
		MinerPass:                cfg["mining.pass"].Value.(*string),
		BlockMinSize:             cfg["block.minsize"].Value.(*int),
		BlockMaxSize:             cfg["block.maxsize"].Value.(*int),
		BlockMinWeight:           cfg["block.minweight"].Value.(*int),
		BlockMaxWeight:           cfg["block.maxweight"].Value.(*int),
		BlockPrioritySize:        cfg["block.prioritysize"].Value.(*int),
		UserAgentComments:        cfg["p2p.useragentcomments"].Value.(*[]string),
		NoPeerBloomFilters:       cfg["p2p.nobloomfilters"].Value.(*bool),
		NoCFilters:               cfg["p2p.nocfilters"].Value.(*bool),
		SigCacheMaxSize:          cfg["chain.sigcachemaxsize"].Value.(*int),
		BlocksOnly:               cfg["p2p.blocksonly"].Value.(*bool),
		TxIndex:                  cfg["chain.notxindex"].Value.(*bool),
		AddrIndex:                cfg["chain.noaddrindex"].Value.(*bool),
		RelayNonStd:              cfg["chain.relaynonstd"].Value.(*bool),
		RejectNonStd:             cfg["chain.rejectnonstd"].Value.(*bool),
		TLSSkipVerify:            cfg["tls.skipverify"].Value.(*bool),
		Wallet:                   cfg["wallet"].Value.(*bool),
		NoInitialLoad:            cfg["wallet.noinitialload"].Value.(*bool),
		WalletPass:               cfg["wallet.pass"].Value.(*string),
		WalletServer:             cfg["rpc.wallet"].Value.(*string),
		CAFile:                   cfg["tls.cafile"].Value.(*string),
		OneTimeTLSKey:            cfg["tls.onetime"].Value.(*bool),
		ServerTLS:                cfg["tls.server"].Value.(*bool),
		LegacyRPCListeners:       cfg["rpc.listen"].Value.(*[]string),
		LegacyRPCMaxClients:      cfg["rpc.maxclients"].Value.(*int),
		LegacyRPCMaxWebsockets:   cfg["rpc.maxwebsockets"].Value.(*int),
		ExperimentalRPCListeners: nil,
	}
	return
}
